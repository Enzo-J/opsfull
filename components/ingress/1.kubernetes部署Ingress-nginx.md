# 一、Ingress-nginx简介

&#8195;Pod的IP以及service IP只能在集群内访问，如果想在集群外访问kubernetes提供的服务，可以使用nodeport、proxy、loadbalacer以及ingress等方式，由于service的IP集群外不能访问，就是使用ingress方式再代理一次，即ingress代理service，service代理pod.
Ingress基本原理图如下：

  ![Ingress-nginx](https://github.com/Lancger/opsfull/blob/master/images/Ingress-nginx.png)
 
# 二、部署nginx-ingress-controller

```bash
# github地址
https://github.com/kubernetes/ingress-nginx
https://kubernetes.github.io/ingress-nginx/

# 1、下载nginx-ingress-controller配置文件
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml

# 2、service-nodeport.yaml为ingress通过nodeport对外提供服务，注意默认nodeport暴露端口为随机，可以编辑该文件自定义端口
Using NodePort:
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/service-nodeport.yaml

# 3、查看ingress-nginx组件状态
root># kubectl get pod -n ingress-nginx
NAME                                        READY   STATUS    RESTARTS   AGE
nginx-ingress-controller-568867bf56-mbvm2   1/1     Running   0          4m46s

查看创建的ingress service暴露的端口：
root># kubectl get svc -n ingress-nginx 
NAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
ingress-nginx   NodePort   10.97.243.123   <none>        80:30725/TCP,443:32314/TCP   5m46s
```

# 二、创建ingress-nginx后端服务

1.创建一个Service及后端Deployment(以nginx为例)

```
cat > deploy-demon.yaml<<\EOF
apiVersion: v1
kind: Service
metadata:
  name: myapp
  namespace: default
spec:
  selector:
    app: myapp
    release: canary
  ports:
  - name: http
    port: 80
    targetPort: 80
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deploy
spec:
  replicas: 2
  selector:
    matchLabels:
      app: myapp
      release: canary
  template:
    metadata:
      labels:
        app: myapp
        release: canary
    spec:
      containers:
      - name: myapp
        image: ikubernetes/myapp:v2
        ports:
        - name: httpd
          containerPort: 80
EOF
          
root># kubectl apply -f deploy-demon.yaml

root># kubectl get pods

root># kubectl get svc myapp
NAME    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
myapp   ClusterIP   10.106.30.175   <none>        80/TCP    59s

# 通过ClusterIP方式内部测试访问Services
root># curl 10.106.30.175
Hello MyApp | Version: v2 | <a href="hostname.html">Pod Name</a>
```

# 三、创建myapp的ingress规则

```
cat > ingress-myapp.yaml<<\EOF
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress-myapp
  namespace: default
  annotations:
    kubernets.io/ingress.class: "nginx"
spec:
  rules:
  - host: www.k8s-devops.com
    http:
      paths:
      - path:
        backend:
          serviceName: myapp
          servicePort: 80
EOF
          
root># kubectl apply -f ingress-myapp.yaml  

root># kubectl get ingress
NAME            HOSTS                ADDRESS         PORTS   AGE
ingress-myapp   www.k8s-devops.com   10.97.243.123   80      5s

# 通过Ingress方式内部测试访问域名
root># curl -x 10.97.243.123:80 http://www.k8s-devops.com
Hello MyApp | Version: v2 | <a href="hostname.html">Pod Name</a>
```

# 四、查看ingress-default-backend的详细信息：

```
root># kubectl exec -n ingress-nginx -it nginx-ingress-controller-568867bf56-mbvm2 -- /bin/sh

$ cat nginx.conf

        ## start server www.k8s-devops.com
        server {
                server_name www.k8s-devops.com ;

                listen 80  ;
                listen 443  ssl http2 ;

                set $proxy_upstream_name "-";

                ssl_certificate_by_lua_block {
                        certificate.call()
                }

                location / {

                        set $namespace      "default";
                        set $ingress_name   "ingress-myapp";
                        set $service_name   "myapp";
                        set $service_port   "80";
                        set $location_path  "/";
                        
```

# 五、测试域名
```
1、这是nginx-ingress-controller采用的deployment部署的多副本
root># kubectl get deployment -A
ingress-nginx          nginx-ingress-controller    6/6     6            6           65m (这里有6个副本)

root># kubectl get svc -n ingress-nginx 
NAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
ingress-nginx   NodePort   10.97.243.123   <none>        80:30725/TCP,443:32314/TCP   69m

root># kubectl describe svc ingress-nginx -n ingress-nginx
Name:                     ingress-nginx
Namespace:                ingress-nginx
Labels:                   app.kubernetes.io/name=ingress-nginx
                          app.kubernetes.io/part-of=ingress-nginx
Annotations:              kubectl.kubernetes.io/last-applied-configuration:
                            {"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"labels":{"app.kubernetes.io/name":"ingress-nginx","app.kubernetes.io/par...
Selector:                 app.kubernetes.io/name=ingress-nginx,app.kubernetes.io/part-of=ingress-nginx
Type:                     NodePort
IP:                       10.97.243.123
Port:                     http  80/TCP
TargetPort:               80/TCP
NodePort:                 http  30725/TCP
Endpoints:                10.244.154.195:80,10.244.154.196:80,10.244.44.197:80 + 3 more...   这里转到6个pod
Port:                     https  443/TCP
TargetPort:               443/TCP
NodePort:                 https  32314/TCP
Endpoints:                10.244.154.195:443,10.244.154.196:443,10.244.44.197:443 + 3 more...
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   <none>

root># kubectl get endpoints -n ingress-nginx
NAME            ENDPOINTS                                                          AGE
ingress-nginx   10.244.154.195:80,10.244.154.196:80,10.244.44.197:80 + 9 more...   68m

Ingress Controller 用 Deployment 方式部署，给它添加一个 Service，类型为 NodePort，部署完成后查看会给出一个端口，通过 kubectl get svc 我们可以查看到这个端口，这个端口在集群的每个节点都可以访问，通过访问集群节点的这个端口就可以访问 Ingress Controller 了。但是集群节点这么多，而且端口又不是 80和443，太不爽了，一般我们会在前面自己搭个负载均衡器，比如用 Nginx，将请求转发到集群各个节点的那个端口上，这样我们访问 Nginx 就相当于访问到 Ingress Controller 了。

# 通过Nodeport方式测试（主机IP+端口）
curl 10.10.0.24:30725
curl 10.10.0.32:30725
curl 10.10.0.23:30725
curl 10.10.0.25:30725
curl 10.10.0.29:30725
curl 10.10.0.12:30725

2、通过Ingress IP 绑定域名测试

root># kubectl get ingress -A
NAMESPACE   NAME            HOSTS                ADDRESS         PORTS   AGE
default     ingress-myapp   www.k8s-devops.com   10.97.243.123   80      45m

root># curl -x 10.97.243.123:80 http://www.k8s-devops.com
```

# 六、Ingress高可用

Ingress高可用，我们可以通过修改deployment的副本数来实现高可用，但是由于ingress承载着整个集群流量的接入，所以生产环境中，建议把ingress通过DaemonSet的方式部署集群中，而且该节点打上污点不允许业务pod进行调度，以避免业务应用与Ingress服务发生资源争抢。然后通过SLB把ingress节点主机添为后端服务器，进行流量转发。

```
2、测试二
#配置集群外域名解析，当前测试环境我们使用windows hosts文件进行解析(针对于node节点有公网IP的类型)
92.168.92.56  www.k8s-devops.com  
92.168.92.57  www.k8s-devops.com 
92.168.92.58  www.k8s-devops.com

使用域名进行访问:
www.k8s-devops.com
```

参考资料：

https://github.com/kubernetes/ingress-nginx/blob/04e2ad8fcd51b0741263a37b8e7424ca3979137c/docs/deploy/index.md  官网

https://blog.csdn.net/networken/article/details/85881558   kubernetes部署Ingress-nginx
